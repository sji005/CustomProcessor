100001000    //mv r1 0 
101000001    //ldr r0 r1
100001001    //mv r1 1
101001001    //ldr r1 r1
100010000    //mv r2 0 
010000010    //sub r0 r2
010001010    //sub r1 r2 
011000110    //b 000 isZero 
100011000 //mv r3 0      
100100001 //mv r4 1
111100110 //regop r4 110 //shiftleft
111100110 //regop r4 110 
111100110 //regop r4 110 //shiftleft
001011100 //flip r3 r4 
100100000 //mv r4 0
010001011 //sub r1 r3
010000100 //sub r0 r4
011100001 //branch ifMost Neg
100001000    //mv r1 0 
101000001    //ldr r0 r1
100001001    //mv r1 1
101001001    //ldr r1 r1
111001000    //regOp r1 000 
111000001    //regOp r0 000
111001011    //regop r1 001
100111001    //mv r7 1
010001111    //sub r1 r7
100011000    //mv r3 0 
010001010    //sub r1 r2 //check for non zero 
010001010    //sub r1 r2
011010001    //b 010 sndPart
100111000    //mv r7 0
100111000    //mv r7 0 
111011011    //regOp r3 011
111000010    //regOp r0 010 
100111100    //mv r7 4
111111110    //shiftleft r7 //r7 has 8
100101000    //mv r5 0
010101011    //sub r5 r3         //move r3 to r5
100110000    //mv r6 0
010110101    //sub r6 r5   //now we have r3 in r6
100101000    //mv r5 0
010101101    //sub r5 r5
010110111    //sub r6 r7
011000001    //b to sndPart
010000010    //sub r0 r2 
010000010    //sub r0 r2 
011000011    //b 000 computeFloat 
010100100    //sub r4 r4 
010100100    //sub r4 r4  
011000000    //b 000 loop1  
100111000    //mv r7 0
100111000    //mv r7 0 
100011001    //mv r3 1
111011110    //regOp r3 110
100111000    //mv r7 0
111011110    //regOp r3 110
100111000    //mv r7 0
111011110    //regOp r3 110 
100111000    //mv r7 0          
100111000    //mv r7 0 
100111000    //mv r7 0 
111011011    //regOp r3 011
111001010    //regOp r1 100
100010000    //mv r2 0 
010001010    //sub r1 r2 
010001010    //sub r1 r2 
011000011    //b 000 computeFloat
010100100    //sub r4 r4 
010100100    //sub r4 r4 
011000010    //b loop2
100111000    //mv r7 0
100111000    //mv r7 0
100111000    //mv r7 0 
100001000	 //mv r1 0	
101000001    //ldr r0 r1
100001001    //mv r1 1
101001001    //ldr r1 r1
111001000    //regOp r1 000 
111000001    //regOp r0 000
111001011    //regop r1 001
100111001    //mv r7 1
010001111    //sub r1 r7
100111001    //mv r7 1
001000011    //flip r0 r3
001001011    //flip r1 r3
100100000    //mv r4 0 
100101000    //mv r5 0 
010101011    //sub r5 r3
100100000    //mv r4 0
010100101    //sub r4 r5 
100101111    //mv r5 7 
010100101    //sub r4 r5
100101100    //mv r5 4
010100101    //sub r4 r5 
100110000    //mv r6 0 
010100110    //sub r4 r6 
011101000    //b 001 align 
010100110             //sub r4 r6
010100110             //sub r4 r6
011000101    //b 000 assemble
100111000    //mv r7 0
100111000    //mv r7 0 
100101001    //mv r5 1
010100101    //sub r4 r5 
111001010    //regOp r1 100 shift right 
111000010    //regOp r0 100 
010100110    //sub r4 r6 
010100110    //sub r4 r6
011000101    //b 000 assemble
010110110    //sub r6 r6 
010110110    //sub r6 r6 
011000100    //b 000 loop3
100111000    //mv r7 0
100111000    //mv r7 0
100111000    //mv r7 0 
100100110    //mv r4 6
010111100    //sub r7 r4 
010011111    //sub r3 r7 
111011110    //regOp r3 110 
111011110    //regOP r3 110
100101000    //mv r5 0
111001010    //regOp r1 010
111101010    //regOp r5 110 
111001010    //regOp r1 010 
111101010    //regOp r5 110 
111101010    //regOp r5 110 
111101010    //regOp r5 110 
111101010    //regOp r5 110 
111101010    //regOp r5 110 
111101010    //regOp r5 110 
111101010    //regOp r5 110 
000011101    //or r3 r5 
100001001          //mv r1 1 
101001001    //ldr r1 r1
111001000    //regop r1 000 //check if negative
111011100    //regop r3 100 //adds the neg bit if msb is negative
100100011    //mv r4 3
110011100    //str r3 r4
100100010    //mv r4 2
110000100    //str r0 r4
010001001    //sub r1 r1
010001001    //sub r1 r1 
011000111    //b 000 111
100111000    //mv r7 0
100111000    //mv r7 0 
100001000    //mv r1 0 
100010011    //mv r2 3
100011010    //mv r3 2
110001010    //str r1 r2
110001011    //str r1 r3 
010001001    //sub r1 r1
010001001    //sub r1 r1 
011000111    //b 000 111
100111000
100111000
100111000
100111000
100111000
100111000 //align:
100110000 //mv r6 0 
111100011 //increment
111000110 //shift left
111001110 //shift left
010100110 //check for 0 
010100110 
011000101 //branch assemble
010110110 
010110110
011100000 //loop
100111000
100111000
100111000 //ifMostNeg
100000110 
100001110
111000110 //regop r0 110 //shift left 5 times
111000110
111000110
111000110
111000110
111001110
111001110
000000001 //or 
100001000 //mv r1 0  //make bot part
100010011
110000010 //str r0 r2
100010010 //mv r2 010
110001010 //str r1 r2
011000111 //done